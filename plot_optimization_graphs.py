"""Utility script to visualise routing optimisation outputs.

The script scans the ``RES/optimization/routes`` directory generated by
``pipeline.py`` and produces a set of reference charts that can be shared with
stakeholders or included in a project report:

* Route map per batch: highlights the visit order for every batch using the
  ``batch_XXX_path.csv`` artefacts.
* Time vs. cost trade-off scatter: plots candidate vehicles per batch based on
  the ``batch_XXX_metrics.csv`` files.
* Global batch summary: compares total minutes and costs for all selected
  batches from ``routes_summary.csv``.
* SLA compliance pie chart: visualises the proportion of batches that meet the
  configured SLA.

Running the script is optional and does not affect automated tests.  Invoke it
after executing ``pipeline.py`` to populate the optimisation results.
"""
from __future__ import annotations

import argparse
from pathlib import Path
from typing import Iterable, Optional

import numpy as np
import pandas as pd

try:  # pragma: no cover - plotting is optional in CI
    import matplotlib.pyplot as plt
except Exception as exc:  # pragma: no cover - keep script importable without MPL
    plt = None
    PLOT_IMPORT_ERROR = exc
else:  # pragma: no cover - MPL available
    PLOT_IMPORT_ERROR = None


DEFAULT_ROUTES_DIR = Path("RES") / "optimization" / "routes"
PLOTS_DIR_NAME = "plots"


def _ensure_matplotlib() -> None:
    if plt is None:
        raise RuntimeError(
            "matplotlib is required for plotting but could not be imported. "
            "Install matplotlib or run the script in an environment where it is available."
        ) from PLOT_IMPORT_ERROR


def _format_group_batch(group: str, batch_id: int) -> str:
    return f"{group}_batch_{batch_id:03d}"


def _load_csv(path: Path) -> Optional[pd.DataFrame]:
    if not path.exists():
        return None
    try:
        return pd.read_csv(path)
    except Exception as exc:
        print(f"[WARN] Failed to read {path}: {exc}")
        return None


def _plot_route(path_df: pd.DataFrame, title: str, out_path: Path) -> None:
    if path_df.empty:
        print(f"[WARN] Empty route data for {title}; skipping")
        return

    path_df = path_df.sort_values("step")
    lats = [path_df.iloc[0]["from_lat"]]
    lons = [path_df.iloc[0]["from_lon"]]
    for _, row in path_df.iterrows():
        lats.append(row["to_lat"])
        lons.append(row["to_lon"])

    lats = np.asarray(lats, dtype=float)
    lons = np.asarray(lons, dtype=float)

    fig, ax = plt.subplots(figsize=(6, 6))
    ax.plot(lons, lats, marker="o", linestyle="-", color="#1f77b4")

    # annotate order (skip depot duplicates at start/end)
    for idx, (lon, lat) in enumerate(zip(lons, lats)):
        label = "Depot" if idx in (0, len(lats) - 1) else str(idx)
        ax.annotate(label, (lon, lat), textcoords="offset points", xytext=(4, 4), fontsize=8)

    ax.set_title(title)
    ax.set_xlabel("Longitude")
    ax.set_ylabel("Latitude")
    ax.grid(True, linestyle="--", alpha=0.5)
    fig.tight_layout()
    fig.savefig(out_path, dpi=200)
    plt.close(fig)


def _plot_tradeoff(metrics_df: pd.DataFrame, title: str, out_path: Path) -> None:
    if metrics_df.empty:
        print(f"[WARN] Empty metrics for {title}; skipping trade-off plot")
        return

    fig, ax = plt.subplots(figsize=(6, 5))
    vehicles = metrics_df.get("vehicle", pd.Series(dtype=str)).astype(str)
    unique_vehicles = sorted(vehicles.unique())
    colors = plt.cm.get_cmap("tab10", len(unique_vehicles))

    selected_mask = metrics_df.get("is_selected", 0).astype(bool)

    for idx, vehicle in enumerate(unique_vehicles):
        mask = vehicles == vehicle
        subset = metrics_df.loc[mask]
        ax.scatter(
            subset["total_min"],
            subset["cost"],
            label=vehicle,
            color=colors(idx),
            alpha=0.8,
            edgecolor="k",
            linewidths=0.5,
        )

    if selected_mask.any():
        sel = metrics_df.loc[selected_mask]
        ax.scatter(
            sel["total_min"],
            sel["cost"],
            s=120,
            facecolors="none",
            edgecolors="red",
            linewidths=1.5,
            label="Selected",
        )

    ax.set_title(title)
    ax.set_xlabel("Total time (minutes)")
    ax.set_ylabel("Cost (currency units)")
    ax.grid(True, linestyle="--", alpha=0.4)
    ax.legend()
    fig.tight_layout()
    fig.savefig(out_path, dpi=200)
    plt.close(fig)


def _plot_summary_bars(summary_df: pd.DataFrame, out_dir: Path) -> None:
    if summary_df.empty:
        print("[WARN] routes_summary.csv is empty; skipping summary plots")
        return

    summary_df = summary_df.copy()
    summary_df.sort_values(["group", "batch_id"], inplace=True)

    labels = [f"{g}\nBatch {int(b):03d}" for g, b in summary_df[["group", "batch_id"]].to_numpy()]

    fig, ax = plt.subplots(figsize=(max(6, len(labels) * 0.9), 5))
    ax.bar(labels, summary_df["total_min"], color="#1f77b4")
    ax.set_ylabel("Total minutes")
    ax.set_title("Selected batch durations")
    ax.set_xticklabels(labels, rotation=30, ha="right")
    fig.tight_layout()
    fig.savefig(out_dir / "summary_total_minutes.png", dpi=200)
    plt.close(fig)

    fig, ax = plt.subplots(figsize=(max(6, len(labels) * 0.9), 5))
    ax.bar(labels, summary_df["cost"], color="#2ca02c")
    ax.set_ylabel("Cost (currency units)")
    ax.set_title("Selected batch costs")
    ax.set_xticklabels(labels, rotation=30, ha="right")
    fig.tight_layout()
    fig.savefig(out_dir / "summary_costs.png", dpi=200)
    plt.close(fig)


def _plot_sla_pie(summary_df: pd.DataFrame, out_dir: Path) -> None:
    if summary_df.empty or "meets_sla" not in summary_df.columns:
        print("[WARN] Cannot draw SLA pie chart; data missing")
        return

    meets = summary_df["meets_sla"].astype(float).fillna(0)
    counts = {
        "Met SLA": float((meets >= 0.5).sum()),
        "Violated": float((meets < 0.5).sum()),
    }

    if counts["Met SLA"] + counts["Violated"] == 0:
        print("[WARN] No SLA labels present; skipping pie chart")
        return

    fig, ax = plt.subplots(figsize=(5, 5))
    ax.pie(counts.values(), labels=counts.keys(), autopct="%1.0f%%", startangle=90)
    ax.set_title("SLA compliance across batches")
    ax.axis("equal")
    fig.tight_layout()
    fig.savefig(out_dir / "sla_compliance.png", dpi=200)
    plt.close(fig)


def generate_plots(routes_dir: Path) -> None:
    _ensure_matplotlib()

    if not routes_dir.exists():
        raise FileNotFoundError(
            f"Routes directory '{routes_dir}' not found. Run pipeline.py to generate optimisation results first."
        )

    plots_dir = routes_dir / PLOTS_DIR_NAME
    plots_dir.mkdir(parents=True, exist_ok=True)

    summary_path = routes_dir / "routes_summary.csv"
    summary_df = _load_csv(summary_path)
    if summary_df is None:
        raise FileNotFoundError(
            f"Required summary file '{summary_path}' not found. Ensure pipeline.py completed successfully."
        )

    _plot_summary_bars(summary_df, plots_dir)
    _plot_sla_pie(summary_df, plots_dir)

    # Iterate over batches for route maps and trade-off scatters
    for _, row in summary_df.iterrows():
        group = str(row.get("group", "Global"))
        batch_id = int(row.get("batch_id", 0))
        label = _format_group_batch(group, batch_id)

        path_csv = row.get("path_csv")
        if isinstance(path_csv, str) and path_csv:
            path_df = _load_csv(Path(path_csv))
            if path_df is not None:
                out_path = plots_dir / f"{label}_route.png"
                _plot_route(path_df, f"Route map – {label}", out_path)
        else:
            print(f"[INFO] No path CSV recorded for {label}; skipping route map")

        metrics_csv = row.get("metrics_csv")
        if isinstance(metrics_csv, str) and metrics_csv:
            metrics_df = _load_csv(Path(metrics_csv))
            if metrics_df is not None:
                out_path = plots_dir / f"{label}_tradeoff.png"
                _plot_tradeoff(metrics_df, f"Time vs cost – {label}", out_path)
        else:
            print(f"[INFO] No metrics CSV recorded for {label}; skipping trade-off plot")

    print(f"Plots stored in: {plots_dir.resolve()}")


def parse_args(argv: Optional[Iterable[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Generate optimisation plots from routing artefacts.")
    parser.add_argument(
        "--routes-dir",
        type=Path,
        default=DEFAULT_ROUTES_DIR,
        help="Path to the RES/optimization/routes directory (default: %(default)s)",
    )
    return parser.parse_args(argv)


def main() -> None:
    args = parse_args()
    generate_plots(args.routes_dir)


if __name__ == "__main__":  # pragma: no cover - manual execution entry point
    main()